// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package xfs

import (
	"io/fs"
	"sync"
)

// Ensure, that DirEntryMock does implement DirEntry.
// If this is not the case, regenerate this file with moq.
var _ DirEntry = &DirEntryMock{}

// DirEntryMock is a mock implementation of DirEntry.
//
//	func TestSomethingThatUsesDirEntry(t *testing.T) {
//
//		// make and configure a mocked DirEntry
//		mockedDirEntry := &DirEntryMock{
//			InfoFunc: func() (fs.FileInfo, error) {
//				panic("mock out the Info method")
//			},
//			IsDirFunc: func() bool {
//				panic("mock out the IsDir method")
//			},
//			NameFunc: func() string {
//				panic("mock out the Name method")
//			},
//			TypeFunc: func() fs.FileMode {
//				panic("mock out the Type method")
//			},
//		}
//
//		// use mockedDirEntry in code that requires DirEntry
//		// and then make assertions.
//
//	}
type DirEntryMock struct {
	// InfoFunc mocks the Info method.
	InfoFunc func() (fs.FileInfo, error)

	// IsDirFunc mocks the IsDir method.
	IsDirFunc func() bool

	// NameFunc mocks the Name method.
	NameFunc func() string

	// TypeFunc mocks the Type method.
	TypeFunc func() fs.FileMode

	// calls tracks calls to the methods.
	calls struct {
		// Info holds details about calls to the Info method.
		Info []struct {
		}
		// IsDir holds details about calls to the IsDir method.
		IsDir []struct {
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
		// Type holds details about calls to the Type method.
		Type []struct {
		}
	}
	lockInfo  sync.RWMutex
	lockIsDir sync.RWMutex
	lockName  sync.RWMutex
	lockType  sync.RWMutex
}

// Info calls InfoFunc.
func (mock *DirEntryMock) Info() (fs.FileInfo, error) {
	if mock.InfoFunc == nil {
		panic("DirEntryMock.InfoFunc: method is nil but DirEntry.Info was just called")
	}
	callInfo := struct {
	}{}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	return mock.InfoFunc()
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//
//	len(mockedDirEntry.InfoCalls())
func (mock *DirEntryMock) InfoCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// IsDir calls IsDirFunc.
func (mock *DirEntryMock) IsDir() bool {
	if mock.IsDirFunc == nil {
		panic("DirEntryMock.IsDirFunc: method is nil but DirEntry.IsDir was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsDir.Lock()
	mock.calls.IsDir = append(mock.calls.IsDir, callInfo)
	mock.lockIsDir.Unlock()
	return mock.IsDirFunc()
}

// IsDirCalls gets all the calls that were made to IsDir.
// Check the length with:
//
//	len(mockedDirEntry.IsDirCalls())
func (mock *DirEntryMock) IsDirCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsDir.RLock()
	calls = mock.calls.IsDir
	mock.lockIsDir.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *DirEntryMock) Name() string {
	if mock.NameFunc == nil {
		panic("DirEntryMock.NameFunc: method is nil but DirEntry.Name was just called")
	}
	callInfo := struct {
	}{}
	mock.lockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	mock.lockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//
//	len(mockedDirEntry.NameCalls())
func (mock *DirEntryMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockName.RLock()
	calls = mock.calls.Name
	mock.lockName.RUnlock()
	return calls
}

// Type calls TypeFunc.
func (mock *DirEntryMock) Type() fs.FileMode {
	if mock.TypeFunc == nil {
		panic("DirEntryMock.TypeFunc: method is nil but DirEntry.Type was just called")
	}
	callInfo := struct {
	}{}
	mock.lockType.Lock()
	mock.calls.Type = append(mock.calls.Type, callInfo)
	mock.lockType.Unlock()
	return mock.TypeFunc()
}

// TypeCalls gets all the calls that were made to Type.
// Check the length with:
//
//	len(mockedDirEntry.TypeCalls())
func (mock *DirEntryMock) TypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockType.RLock()
	calls = mock.calls.Type
	mock.lockType.RUnlock()
	return calls
}
